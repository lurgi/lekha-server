name: Deploy to EC2

on:
  push:
    branches:
      - master

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: inklings-server

permissions:
  id-token: write
  contents: read

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_pass
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2

      - name: Run migrations
        env:
          DATABASE_URL: postgres://test_user:test_pass@localhost:5432/test_db
        run: |
          echo "ğŸ”„ Running database migrations..."
          cargo run -p migration up
          echo "âœ… Migrations completed"

      - name: Run tests
        env:
          DATABASE_URL_TEST: postgres://test_user:test_pass@localhost:5432/test_db
          QDRANT_URL: http://mock:6334
          GEMINI_API_KEY: mock-key
        run: cargo test --all-features

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image with cache
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: inklings-server:test
          cache-from: type=gha
          cache-to: type=gha,mode=max
          load: true

      - name: Start Qdrant for integration test
        run: |
          docker run -d --name qdrant-test \
            -p 6334:6334 \
            -p 6333:6333 \
            qdrant/qdrant:latest

          echo "Waiting for Qdrant to start..."
          for i in {1..30}; do
            if curl -s http://localhost:6333/health > /dev/null 2>&1; then
              echo "âœ… Qdrant is ready"
              break
            fi
            echo "Waiting for Qdrant... ($i/30)"
            sleep 1
          done

      - name: Test container startup
        run: |
          docker run -d --name test-container \
            --network host \
            -e DATABASE_URL=postgres://test_user:test_pass@localhost:5432/test_db \
            -e QDRANT_URL=http://localhost:6334 \
            -e GEMINI_API_KEY=test-api-key \
            -e SERVER_HOST=127.0.0.1 \
            -e SERVER_PORT=8080 \
            -e RUST_LOG=info \
            inklings-server:test

          echo "Waiting for server to start..."
          sleep 10

          echo "=== Container Logs ==="
          docker logs test-container

          if docker ps | grep test-container | grep -q "Up"; then
            echo "âœ… Container is running"
          else
            echo "âŒ Container failed"
            docker logs test-container
            exit 1
          fi

      - name: Test health endpoint
        run: |
          echo "Testing health endpoint..."
          for i in {1..10}; do
            response=$(curl -s http://localhost:8080/api/health || echo "failed")
            if echo "$response" | grep -q "ok"; then
              echo "âœ… Health check passed"
              echo "Response: $response"
              exit 0
            fi
            echo "Attempt $i/10 failed, retrying..."
            sleep 2
          done

          echo "âŒ Health check failed"
          docker logs test-container
          exit 1

      - name: Cleanup test
        if: always()
        run: |
          docker stop test-container || true
          docker rm test-container || true
          docker stop qdrant-test || true
          docker rm qdrant-test || true

  deploy:
    needs: test  # âœ… í…ŒìŠ¤íŠ¸ í†µê³¼í•´ì•¼ë§Œ ë°°í¬
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Validate EC2 environment
        run: |
          echo "ğŸ” Validating EC2 environment variables..."

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "set -e",
              "echo \"Checking required files and environment variables...\"",
              "cd /home/ubuntu/inklings-server || { echo \"âŒ Project directory not found\"; exit 1; }",
              "echo \"âœ… Project directory exists\"",
              "",
              "if [ ! -f .env ]; then",
              "  echo \"âŒ .env file not found\"",
              "  exit 1",
              "fi",
              "echo \"âœ… .env file exists\"",
              "",
              "echo \"Checking required environment variables...\"",
              "missing_vars=\"\"",
              "",
              "check_var() {",
              "  if ! grep -q \"^$1=\" .env; then",
              "    echo \"âŒ Missing: $1\"",
              "    missing_vars=\"$missing_vars $1\"",
              "    return 1",
              "  else",
              "    echo \"âœ… Found: $1\"",
              "    return 0",
              "  fi",
              "}",
              "",
              "check_var \"GEMINI_API_KEY\"",
              "check_var \"QDRANT_URL\"",
              "check_var \"POSTGRES_USER\"",
              "check_var \"POSTGRES_PASSWORD\"",
              "check_var \"POSTGRES_DB\"",
              "",
              "if [ -n \"$missing_vars\" ]; then",
              "  echo \"\"",
              "  echo \"âŒ Validation failed: Missing environment variables:$missing_vars\"",
              "  echo \"Please add them to /home/ubuntu/inklings-server/.env\"",
              "  exit 1",
              "fi",
              "",
              "echo \"\"",
              "echo \"âœ… All required environment variables are set\"",
              "",
              "if [ ! -f docker-compose.prod.yml ]; then",
              "  echo \"âŒ docker-compose.prod.yml not found\"",
              "  exit 1",
              "fi",
              "echo \"âœ… docker-compose.prod.yml exists\"",
              "",
              "echo \"\"",
              "echo \"ğŸ‰ Environment validation passed!\""
            ]' \
            --comment "Validate EC2 environment" \
            --region ${{ env.AWS_REGION }} \
            --output text \
            --query 'Command.CommandId')

          echo "ğŸ“ Validation Command ID: $COMMAND_ID"

          # ëª…ë ¹ ì™„ë£Œ ëŒ€ê¸°
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }}

          # ê²°ê³¼ í™•ì¸
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Status' \
            --output text)

          # ë¡œê·¸ ì¶œë ¥
          echo "ğŸ“„ Validation results:"
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'StandardOutputContent' \
            --output text

          if [ "$STATUS" != "Success" ]; then
            echo ""
            echo "âŒ Environment validation failed"
            echo "Error details:"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
              --region ${{ env.AWS_REGION }} \
              --query 'StandardErrorContent' \
              --output text
            echo ""
            echo "ğŸ› ï¸  To fix:"
            echo "  1. SSH into EC2: ssh ec2-user@your-instance"
            echo "  2. Edit .env: cd /home/ubuntu/inklings-server && nano .env"
            echo "  3. Add missing variables"
            echo "  4. Re-run this workflow"
            exit 1
          fi

          echo "âœ… Environment validation completed successfully!"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image with cache
        uses: docker/build-push-action@v5
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        with:
          context: .
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Save current image tag
        id: save-current-image
        run: |
          echo "ğŸ’¾ Saving current running image for potential rollback..."

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /home/ubuntu/inklings-server",
              "docker compose -f docker-compose.prod.yml images api --format json | jq -r \".[0].Repository + \\\":\\\" + .[0].Tag\" || echo \"none\""
            ]' \
            --region ${{ env.AWS_REGION }} \
            --output text \
            --query 'Command.CommandId')

          # ëª…ë ¹ ì™„ë£Œ ëŒ€ê¸°
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }}

          # í˜„ì¬ ì´ë¯¸ì§€ íƒœê·¸ ì¶”ì¶œ
          CURRENT_IMAGE=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'StandardOutputContent' \
            --output text | tr -d '\n')

          echo "Current image: $CURRENT_IMAGE"
          echo "ROLLBACK_IMAGE=$CURRENT_IMAGE" >> $GITHUB_ENV

          if [ "$CURRENT_IMAGE" = "none" ]; then
            echo "âš ï¸  No existing image found (first deployment?)"
          else
            echo "âœ… Saved current image for rollback: $CURRENT_IMAGE"
          fi

      - name: Deploy to EC2 via SSM
        id: deploy
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          echo "ğŸš€ Starting deployment to EC2..."

          # SSM ëª…ë ¹ ì‹¤í–‰ ë° Command ID ì €ì¥
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "set -e",
              "echo \"ğŸ“ Navigating to project directory...\"",
              "cd /home/ubuntu/inklings-server || { echo \"âŒ Failed to cd\"; exit 1; }",
              "echo \"ğŸ” Logging in to ECR...\"",
              "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }} || { echo \"âŒ ECR login failed\"; exit 1; }",
              "echo \"â¬‡ï¸  Pulling latest Docker image...\"",
              "docker pull ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest || { echo \"âŒ Docker pull failed\"; exit 1; }",
              "echo \"\"",
              "echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"",
              "echo \"ğŸ”„ Running database migrations\"",
              "echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"",
              "echo \"âš ï¸  Migration Policy: Forward-only, backward-compatible\"",
              "echo \"\"",
              "echo \"ğŸ“Š Checking current migration status...\"",
              "docker compose -f docker-compose.prod.yml run --rm api ./migration status || echo \"Status check skipped\"",
              "echo \"\"",
              "echo \"ğŸš€ Applying migrations...\"",
              "if ! docker compose -f docker-compose.prod.yml run --rm api ./migration up; then",
              "  echo \"\"",
              "  echo \"âŒ Migration failed!\"",
              "  echo \"\"",
              "  echo \"ğŸ›‘ Deployment aborted to prevent DB/code version mismatch\"",
              "  echo \"\"",
              "  echo \"ğŸ” Troubleshooting:\"",
              "  echo \"  1. Check migration syntax: migration/src/*.rs\"",
              "  echo \"  2. Check DB connectivity\"",
              "  echo \"  3. Review migration logs above\"",
              "  echo \"\"",
              "  exit 1",
              "fi",
              "echo \"\"",
              "echo \"âœ… Migrations applied successfully\"",
              "echo \"\"",
              "echo \"ğŸ“Š Final migration status:\"",
              "docker compose -f docker-compose.prod.yml run --rm api ./migration status || echo \"Status check skipped\"",
              "echo \"\"",
              "echo \"ğŸ”„ Updating API containers (zero-downtime)...\"",
              "docker compose -f docker-compose.prod.yml up -d --no-deps api || { echo \"âŒ API update failed\"; exit 1; }",
              "",
              "echo \"â³ Waiting for containers to be healthy...\"",
              "for i in {1..30}; do",
              "  RUNNING=$(docker compose -f docker-compose.prod.yml ps api --format json 2>/dev/null | jq -r '.State' | grep -c running || echo 0)",
              "  if [ \"$RUNNING\" -gt 0 ]; then",
              "    echo \"âœ… Containers are running (attempt $i/30)\"",
              "    break",
              "  fi",
              "  echo \"Waiting for containers to start... ($i/30)\"",
              "  sleep 1",
              "done",
              "echo \"âœ… Rolling update completed\"",
              "echo \"âœ… Deployment commands completed\"",
              "echo \"ğŸ“Š Container status:\"",
              "docker compose -f docker-compose.prod.yml ps"
            ]' \
            --comment "Deploy inklings-server:latest from GitHub Actions" \
            --region ${{ env.AWS_REGION }} \
            --output text \
            --query 'Command.CommandId')

          echo "ğŸ“ Command ID: $COMMAND_ID"

          # ëª…ë ¹ ì‹¤í–‰ ì™„ë£Œ ëŒ€ê¸° (ìµœëŒ€ 5ë¶„)
          echo "â³ Waiting for deployment to complete..."
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} || {
              echo "âŒ Deployment command timed out or failed"
              exit 1
            }

          # ëª…ë ¹ ì‹¤í–‰ ê²°ê³¼ í™•ì¸
          echo "ğŸ“‹ Checking command execution status..."
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Status' \
            --output text)

          echo "Status: $STATUS"

          # ìƒì„¸ ë¡œê·¸ ì¶œë ¥
          echo "ğŸ“„ Deployment logs:"
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'StandardOutputContent' \
            --output text

          # ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë¡œê·¸ ì¶œë ¥
          if [ "$STATUS" != "Success" ]; then
            echo "âŒ Deployment failed with status: $STATUS"
            echo "ğŸ“„ Error logs:"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
              --region ${{ env.AWS_REGION }} \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi

          echo "âœ… Deployment completed successfully!"

      - name: Verify deployment health
        run: |
          echo "ğŸ¥ Verifying deployment health..."

          # EC2ì—ì„œ ì»¨í…Œì´ë„ˆ ìƒíƒœ í™•ì¸
          echo "ğŸ“Š Step 1: Checking container status..."
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /home/ubuntu/inklings-server",
              "echo \"=== Container Status ===\"",
              "docker compose -f docker-compose.prod.yml ps",
              "echo \"\"",
              "echo \"=== API Container Logs (last 20 lines) ===\"",
              "docker compose -f docker-compose.prod.yml logs --tail=20 api"
            ]' \
            --region ${{ env.AWS_REGION }} \
            --output text \
            --query 'Command.CommandId')

          # ëª…ë ¹ ì™„ë£Œ ëŒ€ê¸°
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }}

          # ê²°ê³¼ ì¶œë ¥
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'StandardOutputContent' \
            --output text

          echo "âœ… Container status check completed"
          echo ""

          # Health endpoint í™•ì¸ (SSMì„ í†µí•œ ë‚´ë¶€ ì ‘ê·¼)
          echo "ğŸ” Step 2: Verifying health endpoint (internal check via SSM)..."
          echo "ğŸ”’ Using secure SSM connection (no public IP exposure)"
          echo ""
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo \"Testing health endpoint...\"",
              "for i in {1..10}; do",
              "  response=$(curl -s http://localhost:8080/api/health || echo \"failed\")",
              "  if echo \"$response\" | grep -q \"ok\"; then",
              "    echo \"âœ… Health check passed: $response\"",
              "    exit 0",
              "  fi",
              "  echo \"Attempt $i/10 failed, retrying...\"",
              "  sleep 2",
              "done",
              "echo \"âŒ Health check failed after 10 attempts\"",
              "exit 1"
            ]' \
            --region ${{ env.AWS_REGION }} \
            --output text \
            --query 'Command.CommandId')

          # ëª…ë ¹ ì™„ë£Œ ëŒ€ê¸°
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }}

          # ìƒíƒœ í™•ì¸
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Status' \
            --output text)

          # ê²°ê³¼ ì¶œë ¥
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'StandardOutputContent' \
            --output text

          if [ "$STATUS" != "Success" ]; then
            echo "âŒ Internal health check failed"
            echo "Error logs:"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
              --region ${{ env.AWS_REGION }} \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi

          echo ""
          echo "âœ… All health checks passed!"
          echo "ğŸ‰ Deployment verified successfully!"

      - name: Rollback on failure
        if: failure() && env.ROLLBACK_IMAGE != 'none' && env.ROLLBACK_IMAGE != ''
        run: |
          echo "âš ï¸  Deployment or health check failed!"
          echo "ğŸ”„ Rolling back to previous version: ${{ env.ROLLBACK_IMAGE }}"

          # ì´ì „ ì´ë¯¸ì§€ë¡œ ë¡¤ë°±
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "set -e",
              "echo \"ğŸ”™ Starting rollback to previous version...\"",
              "cd /home/ubuntu/inklings-server || exit 1",
              "",
              "echo \"ğŸ“ Current image to rollback to: ${{ env.ROLLBACK_IMAGE }}\"",
              "",
              "echo \"ğŸ” Verifying rollback image exists...\"",
              "if ! docker image inspect ${{ env.ROLLBACK_IMAGE }} >/dev/null 2>&1; then",
              "  echo \"âŒ ERROR: Rollback image not found: ${{ env.ROLLBACK_IMAGE }}\"",
              "  echo \"Available images:\"",
              "  docker images | grep ${{ env.ECR_REPOSITORY }} || echo \"No images found\"",
              "  echo \"\"",
              "  echo \"ğŸ†˜ Cannot rollback - previous image is missing!\"",
              "  exit 1",
              "fi",
              "echo \"âœ… Rollback image verified\"",
              "",
              "echo \"ğŸ”„ Stopping current API containers...\"",
              "docker compose -f docker-compose.prod.yml down api",
              "",
              "echo \"ğŸ·ï¸  Tagging rollback image as latest...\"",
              "if ! docker tag ${{ env.ROLLBACK_IMAGE }} ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest; then",
              "  echo \"âŒ ERROR: Failed to tag rollback image\"",
              "  echo \"This should never happen if the image exists. Check Docker daemon.\"",
              "  exit 1",
              "fi",
              "echo \"âœ… Image tagged successfully\"",
              "",
              "echo \"ğŸš€ Starting API with rollback image...\"",
              "docker compose -f docker-compose.prod.yml up -d --no-deps api",
              "",
              "echo \"â³ Waiting for rollback containers to be healthy...\"",
              "for i in {1..30}; do",
              "  RUNNING=$(docker compose -f docker-compose.prod.yml ps api --format json 2>/dev/null | jq -r '.State' | grep -c running || echo 0)",
              "  if [ \"$RUNNING\" -gt 0 ]; then",
              "    echo \"âœ… Rollback containers are running (attempt $i/30)\"",
              "    break",
              "  fi",
              "  echo \"Waiting for containers to start... ($i/30)\"",
              "  sleep 1",
              "done",
              "",
              "echo \"ğŸ“Š Container status after rollback:\"",
              "docker compose -f docker-compose.prod.yml ps",
              "",
              "echo \"âœ… Rollback deployment completed\""
            ]' \
            --comment "Rollback to previous version" \
            --region ${{ env.AWS_REGION }} \
            --output text \
            --query 'Command.CommandId')

          echo "ğŸ“ Rollback Command ID: $COMMAND_ID"

          # ë¡¤ë°± ëª…ë ¹ ì™„ë£Œ ëŒ€ê¸°
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }}

          # ë¡¤ë°± ìƒíƒœ í™•ì¸
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Status' \
            --output text)

          # ë¡œê·¸ ì¶œë ¥
          echo "ğŸ“„ Rollback execution logs:"
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'StandardOutputContent' \
            --output text

          if [ "$STATUS" != "Success" ]; then
            echo "âŒ Rollback command failed"
            echo "Error details:"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
              --region ${{ env.AWS_REGION }} \
              --query 'StandardErrorContent' \
              --output text
            echo ""
            echo "ğŸ†˜ CRITICAL: Rollback failed! Manual intervention required."
            echo "SSH into the server and check container status:"
            echo "  docker compose -f docker-compose.prod.yml ps"
            echo "  docker compose -f docker-compose.prod.yml logs api"
            exit 1
          fi

          # ë¡¤ë°± í›„ Health Check
          echo ""
          echo "ğŸ¥ Verifying rollback health..."
          HEALTH_COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo \"Testing health endpoint after rollback...\"",
              "for i in {1..10}; do",
              "  response=$(curl -s http://localhost:8080/api/health || echo \"failed\")",
              "  if echo \"$response\" | grep -q \"ok\"; then",
              "    echo \"âœ… Rollback health check passed: $response\"",
              "    exit 0",
              "  fi",
              "  echo \"Attempt $i/10 failed, retrying...\"",
              "  sleep 2",
              "done",
              "echo \"âŒ Rollback health check failed\"",
              "exit 1"
            ]' \
            --region ${{ env.AWS_REGION }} \
            --output text \
            --query 'Command.CommandId')

          # Health check ì™„ë£Œ ëŒ€ê¸°
          aws ssm wait command-executed \
            --command-id "$HEALTH_COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }}

          # Health check ê²°ê³¼
          HEALTH_STATUS=$(aws ssm get-command-invocation \
            --command-id "$HEALTH_COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Status' \
            --output text)

          aws ssm get-command-invocation \
            --command-id "$HEALTH_COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ${{ env.AWS_REGION }} \
            --query 'StandardOutputContent' \
            --output text

          if [ "$HEALTH_STATUS" != "Success" ]; then
            echo ""
            echo "âŒ Rollback completed but health check still failing"
            echo "ğŸ†˜ CRITICAL: Service is down. Immediate manual intervention required!"
            exit 1
          fi

          echo ""
          echo "âœ… Rollback successful! Service restored to previous version."
          echo ""
          echo "âš ï¸  IMPORTANT: Database Schema Warning"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "The database schema has been migrated to the LATEST version,"
          echo "but the application code has been rolled back to a PREVIOUS version."
          echo ""
          echo "This is SAFE only if your migrations are backward-compatible."
          echo ""
          echo "ğŸ” What to check:"
          echo "  1. Ensure the previous app version can work with the new schema"
          echo "  2. Review migration changes that were applied"
          echo "  3. Check for any new required columns or breaking changes"
          echo ""
          echo "ğŸ› ï¸  If incompatible:"
          echo "  1. Fix the deployment issue in the new version"
          echo "  2. Deploy the fixed version"
          echo "  3. DO NOT manually rollback migrations (risk of data loss)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“‹ Check the deployment logs above to identify the issue."
          exit 1  # ë¡¤ë°± ì„±ê³µí–ˆì§€ë§Œ ë°°í¬ëŠ” ì‹¤íŒ¨í–ˆìœ¼ë¯€ë¡œ exit 1
